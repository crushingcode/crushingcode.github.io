<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gradle on Crushing C.O.D.E</title>
    <link>http://crushingcode.github.io/tags/gradle/</link>
    <description>Recent content in Gradle on Crushing C.O.D.E</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2015</copyright>
    <lastBuildDate>Sat, 03 Sep 2016 10:54:24 +0200</lastBuildDate>
    <atom:link href="http://crushingcode.github.io/tags/gradle/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Update Dependencies.Code.Repeat.</title>
      <link>http://crushingcode.github.io/update-dependencies-code-repeat/</link>
      <pubDate>Sat, 03 Sep 2016 10:54:24 +0200</pubDate>
      
      <guid>http://crushingcode.github.io/update-dependencies-code-repeat/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://crushingcode.github.io/images/posts/updatedependency/header.jpg&#34; alt=&#34;geader&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agree or not agree but on an average consensus pretty much every android dev goes through the loop of &lt;strong&gt;Update Dependencies.Code.Repeat.&lt;/strong&gt; for each of his/her android project. Its frustrating, a waste of time and super annoying when you would want to have the same version across all projects.&lt;/p&gt;

&lt;p&gt;One of such situations that I recently got into was trying to keep all my &lt;strong&gt;&lt;a href=&#34;https://github.com/nisrulz/android-examples&#34;&gt;Android-Examples&lt;/a&gt;&lt;/strong&gt; repository on github updates. As you can see it has multiple small and simple examples of completely functional android example apps. Keeping all of them updated was becoming a hard task whenever a new version android-gradle-plugin, a new support library or google play services would be released. Initially I would go onto update each app in the repository and then commiting it back in. As you can see it wasn&amp;rsquo;t the most efficient way to do it. So sometime back I decided that I am going to put an end to this process and make all version configurations common to all apps and thus escape the &lt;strong&gt;Update Dependencies.Code.Repeat.&lt;/strong&gt; loop of hell.&lt;/p&gt;

&lt;p&gt;So now that I had decided to not update each app individually, I decided to look at my options. The obvious one here was Gradle that supported variables.&lt;/p&gt;

&lt;p&gt;Now we all might have done this for &lt;code&gt;support-library&lt;/code&gt; , where we define a variable inside our module&amp;rsquo;s &lt;code&gt;build.gradle&lt;/code&gt; and  then reference it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;def  supportLibVer = &amp;quot;24.2.0&amp;quot;
..
dependencies {
  compile &amp;quot;com.android.support:appcompat-v7:$supportLibVer&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what I have done here is basically&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Defined a variable named &lt;code&gt;supportLibVer&lt;/code&gt; with the value &lt;code&gt;24.2.0&lt;/code&gt; using &lt;code&gt;def&lt;/code&gt; keyword.&lt;/li&gt;
&lt;li&gt;Next referenced it by using it in the &lt;code&gt;compile&lt;/code&gt; statement as &lt;code&gt;$supportLibVer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the surrounding quote is a double quote &lt;code&gt;&amp;quot;&lt;/code&gt; and not a single quote.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now this approach is basically using a &lt;a href=&#34;https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:local_variables&#34;&gt;Local Variable &lt;/a&gt;, which means that this variable works in the scope of the &lt;code&gt;build.gradle&lt;/code&gt; file it is defined in.&lt;/p&gt;

&lt;p&gt;We want to &lt;strong&gt;&lt;em&gt;externalize&lt;/em&gt;&lt;/strong&gt; the variable from outside the &lt;code&gt;build.gradle&lt;/code&gt; file of the module, so as to provide values to all modules of the project.
Gradle&amp;rsquo;s &lt;a href=&#34;https://docs.gradle.org/current/userguide/writing_build_scripts.html#sec:extra_properties&#34;&gt;Extra properties&lt;/a&gt; come to the rescue.&lt;/p&gt;

&lt;p&gt;The way we use them is by moving our varibales to an &lt;code&gt;ext&lt;/code&gt; block inside the project&amp;rsquo;s root &lt;code&gt;build.gradle&lt;/code&gt; file and reference it as below&lt;/p&gt;

&lt;p&gt;Project&amp;rsquo;s root &lt;code&gt;build.gradle&lt;/code&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;ext {
    supportLibVer = &amp;quot;24.2.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now reference it in all/required modules as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;..
dependencies {
  compile &amp;quot;com.android.support:appcompat-v7:$rootProject.ext.supportLibVer&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice that referencing variable is changed now to &lt;code&gt;$rootProject.ext.supportLibVer&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;..hmm looks like we are going to somewhere with this. So till now we have been able to externailze the variables so as to facilitate common values to the multiple modules inside a particluar project.&lt;/p&gt;

&lt;p&gt;But my requirement was a step ahead than this. I wanted to provide common values to all projects inside my repository and not just to one particular project. So I needed to provide an external &lt;code&gt;gradle&lt;/code&gt; file (that I place at the root of the folder which contains all my my projects) with all &lt;code&gt;ext&lt;/code&gt; variables defined in it , something like this [&lt;a href=&#34;https://github.com/nisrulz/android-examples/blob/master/dependencies.gradle&#34;&gt;dependencies.gradle&lt;/a&gt;]&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;ext {
   androidPluginVer = &amp;quot;2.1.3&amp;quot;
   compileSdkVer = 24
   buildToolsVer = &amp;quot;24.0.2&amp;quot;

   minSdkVer = 9
   targetSdkVer = 24

   supportLibVer = &amp;quot;24.2.0&amp;quot;
   googlePlayServicesVer = &amp;quot;9.4.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but how do I make them available to each &lt;strong&gt;sub-module&lt;/strong&gt; inside each of my projects? I had to dig the gradle docs and buried deep inside is a section that talks about it, called &lt;a href=&#34;https://docs.gradle.org/current/userguide/multi_project_builds.html#sec:subproject_configuration&#34;&gt;Subproject Configuration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So after some practical experimentation i figured out how I can use it to facilitate the &lt;code&gt;ext&lt;/code&gt; variables to &lt;strong&gt;sub-modules&lt;/strong&gt; of each project.
This is what I did next in each Project&amp;rsquo;s root &lt;code&gt;build.gradle&lt;/code&gt;, I added a &lt;code&gt;subprojects&lt;/code&gt; configuration section just below &lt;code&gt;allprojects&lt;/code&gt; configuration section and added a &lt;code&gt;apply from:&lt;/code&gt; statement to apply my external gradle file to each sub-module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    ...
}

allprojects {
    ..
}

// This is added to apply the gradle file to each module under the project
subprojects {
    apply from: &#39;../../dependencies.gradle&#39;
}
..

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this did was it made my external variables defined in &lt;code&gt;dependencies.gradle&lt;/code&gt; files available to each module in each of my projects now and I could now reference them simply as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;..
dependencies {
  compile &amp;quot;com.android.support:appcompat-v7:$supportLibVer&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good. Now this makes life so much easy and now I can provide common values to all the dependencies.
But if you would try to provide a variable and facilitate the version for &lt;code&gt;android-gradle-plugin&lt;/code&gt;, you would see that this wont work. Well thats a bummer, as I needed to make that as a common variable too.&lt;/p&gt;

&lt;p&gt;So after much experimentation, I figured out it was because when we define the &lt;code&gt;subprojects&lt;/code&gt; configuration , it doesnot apply to the root project&amp;rsquo;s &lt;code&gt;build.gradle&lt;/code&gt;. Hmm, this is news as we had almost solved the problem.&lt;/p&gt;

&lt;p&gt;So the way I solved this is by applying the &lt;code&gt;dependencies.gradle&lt;/code&gt; to the &lt;code&gt;buildscript&lt;/code&gt; section directly inside the root &lt;code&gt;build.gradle&lt;/code&gt; for each Project. So now each project&amp;rsquo;s root &lt;code&gt;build.gradle&lt;/code&gt; script became as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    // This is added to apply the gradle file to facilitate providing variable values to root build.gradle of the project
    apply from: &#39;../dependencies.gradle&#39;
    ..
    dependencies {
        classpath &amp;quot;com.android.tools.build:gradle:$androidPluginVer&amp;quot;
        ..
    }
}


allprojects {
    ..
}

// This is added to apply the gradle file to each module under the project
subprojects {
    apply from: &#39;../../dependencies.gradle&#39;
}
..

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/nisrulz/android-examples/blob/master/ActivityLifecycle/build.gradle&#34;&gt;Here is a functional root &lt;code&gt;build.gradle&lt;/code&gt; script from one of the project of my repository itself&lt;/a&gt; and &lt;a href=&#34;https://github.com/nisrulz/android-examples/blob/master/ActivityLifecycle/app/build.gradle&#34;&gt;Here is a functional module &lt;code&gt;build.gradle&lt;/code&gt; script from the same project of my repository itself&lt;/a&gt;. You can see i extended the idea to start externalizing the variable for &lt;code&gt;buildToolsVersion&lt;/code&gt; and &lt;code&gt;compileSdkVersion&lt;/code&gt; too :D&lt;/p&gt;

&lt;p&gt;Great! Now we only need to change the values inside the &lt;code&gt;dependencies.gradle&lt;/code&gt; file and hey presto! when ever I would be loading up any of the projects , they will reference the values from this file and would automagically be working of the most udpated version.&lt;/p&gt;

&lt;p&gt;You can checkout the &lt;a href=&#34;https://github.com/nisrulz/android-examples&#34;&gt;Android-Examples&lt;/a&gt; repository to see a fully functional model of this approach.&lt;/p&gt;

&lt;p&gt;Phew, thats all for this time. Hoping it will solve any similar problems, as this approach can be definitely be extended.&lt;/p&gt;

&lt;p&gt;Comment/Suggest me a better approach, if you know one.&lt;/p&gt;

&lt;p&gt;Keep on crushing code!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The curious case of dependency conflicts</title>
      <link>http://crushingcode.github.io/the-curious-case-of-dependency-conflicts/</link>
      <pubDate>Mon, 02 May 2016 10:54:24 +0200</pubDate>
      
      <guid>http://crushingcode.github.io/the-curious-case-of-dependency-conflicts/</guid>
      <description>

&lt;p&gt;If I were to ask a question to a room filled with android developers&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;How many of you have been in that place of sheer helplessness and panic when your gradle build fails because of a version conflict in dependencies?&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;..I am pretty sure a lot of them would raise their hand or agree to being in that state and the very first action would be to hop onto stackoverflow and search for possible solutions in this type of a situation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://crushingcode.github.io/images/posts/depconflicts.jpg&#34; alt=&#34;depconflicts&#34; /&gt;
&lt;!-- Image taken from freepik.com and all credit goes to the creator of it --&gt;&lt;/p&gt;

&lt;p&gt;We all have been there and we all have experienced it. The problem is a result of each library following a completely different development lifecycle and using a different version of a public api, which by far all means is not the problem which needs to be rectified.
You can&amp;rsquo;t just ask all android library developers/team maintaining it to update the library to use either the lastest or some specific version of a dependency just because it works with another library and/or is causing a conflict when you have both of them in your project.&lt;/p&gt;

&lt;p&gt;So what exactly are the options available to us..&lt;/p&gt;

&lt;p&gt;I stumbled upon such a situation sometime back in the last month or so and as the whole journey to fix this type of conflict was suprisingly less documented on the web , here is my record of how I solved it.&lt;/p&gt;

&lt;p&gt;Now the process I followed may not be the best one out there but it sure did led me to hunt down the solution along with digging out some pretty neat tricks possible using &lt;strong&gt;&lt;em&gt;Gradle Build System&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Before we begin lets get acquinted with some terms we would be using a lot in this whole writeup.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gradle&lt;/strong&gt; - Build system for android&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dependency&lt;/strong&gt; - Libraries such as support libraries in your build.gradle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;transitive dependency&lt;/strong&gt; - Libraries on which dependencies defined in your project depend on&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;conflict&lt;/strong&gt; - incompatible or at variance/clash&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gradlew&lt;/strong&gt; - gradle wrapper&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The important term here for us (in regards to our problem of conflicting dependencies) is &lt;strong&gt;&lt;em&gt;transitive dependency&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You see when you have multiple dependencies defined in your build.gradle, you can never be sure of what do those dependencies further depend on.&lt;/p&gt;

&lt;p&gt;Lets take a simple example&lt;/p&gt;

&lt;p&gt;Say you have 3 android libraries defined under your build.gradle for the app , namely &lt;strong&gt;libA&lt;/strong&gt;, &lt;strong&gt;libB&lt;/strong&gt; and &lt;strong&gt;libC&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;
dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile &#39;com.company1.sdk:libA:1.0.2&#39;
    compile &#39;com.company2.sdk:libB:2.0.3&#39;
    compile &#39;com.company3.sdk:libC:3.0.4&#39;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for you as an android dev the only dependencies in view are &lt;strong&gt;libA&lt;/strong&gt;, &lt;strong&gt;libB&lt;/strong&gt; and &lt;strong&gt;libC&lt;/strong&gt;. You have no idea what these android libraries furthur depend upon.&lt;/p&gt;

&lt;p&gt;The situation which might cause a conflict would be if &lt;strong&gt;libA&lt;/strong&gt; depends on say &lt;strong&gt;libD&lt;/strong&gt; (version 4.0.4) and &lt;strong&gt;libC&lt;/strong&gt; depends on say &lt;strong&gt;libD&lt;/strong&gt; (version 4.0.2).&lt;/p&gt;

&lt;p&gt;Now by default &lt;em&gt;Gradle&lt;/em&gt; would resolve to the latest version of &lt;strong&gt;libD&lt;/strong&gt;. But this is where the problem actually lies.&lt;/p&gt;

&lt;p&gt;You see when you build your code it only says there is conflict in the &lt;strong&gt;libD&lt;/strong&gt; dependency. Thats all.&lt;/p&gt;

&lt;p&gt;So how do you hunt it down.&lt;/p&gt;

&lt;p&gt;well there are a few ways you can do that, the easiest one uses the &lt;code&gt;gradle wrapper&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;step-1&#34;&gt;&lt;strong&gt;STEP 1&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Look for all android dependencies being downloaded as part of the build process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./gradlew androidDependencies
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..you should get a graph like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;...
release
+--- com.company1.sdk:libA:1.0.2
|    +--- com.company4.sdk:libD:4.0.4
+--- com.company2.sdk:libB:2.0.3
|
+--- com.company3.sdk:libA:3.0.4
     +--- com.company4.sdk:libD:4.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..hmm..its becoming a bit more clear now. We can see which version of transitive dependencies are being pulled by which dependency.&lt;/p&gt;

&lt;p&gt;So what exactly happened here?&lt;/p&gt;

&lt;p&gt;The declared dependencies inside your build.gradle file actually download some more libraries on their own since its integral to their functioning. Transitive dependency defined for a declared library could conflict with another transitive dependeny defined for another declared library in version.&lt;/p&gt;

&lt;p&gt;Whats wrong here, you ask  ?  When a library was written to work with older version of the &lt;strong&gt;&lt;em&gt;transitive  dependency&lt;/em&gt;&lt;/strong&gt; then it will basically break if provided with a higher version of the same, probably because the API changed or some classes were removed/renamed (between version updates)from what it was coded to reference and work with.&lt;/p&gt;

&lt;p&gt;Well if you are able to find your problem then you can jump to the solution directly, but if you are still looking for answers then read on.&lt;/p&gt;

&lt;p&gt;Looks like you are still in trouble!&lt;/p&gt;

&lt;p&gt;Considering that you still cannot find the conflicting dependencies and their versions and assuming that its not conflicting from a dependency declared in the build.gradle file but (..probably) introduced by some gradle-plugin defined, we will do a more verbose checkup which is what STEP 2 is about&lt;/p&gt;

&lt;h3 id=&#34;step-2&#34;&gt;&lt;strong&gt;STEP 2&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Check the complete stacktrace of the build process using &lt;code&gt;--info&lt;/code&gt; and &lt;code&gt;--stacktrace&lt;/code&gt; flags passed as arguments&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./gradlew build --info --stacktrace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should give you a complete log of everything and where exactly the build failed.You can find out the version conflicts and a lot more details in this step.&lt;/p&gt;

&lt;p&gt;In my case this was the very case where I was having a conflict on annotations library introduced by the findbugs gradle plugin.&lt;/p&gt;

&lt;p&gt;Well, ok so this is a problem we have got. Whats the solution ? how do you go against the default behaviour of gradle and resolve to a lower version when a conflict occurs ?&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;&lt;strong&gt;SOLUTION&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Well this is where the flexibility of Gradle comes into view. This is not commonly known but is a very useful functionality tucked away into the &lt;a href=&#34;https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:failOnVersionConflict()&#34;&gt;api docs&lt;/a&gt; for gradle.&lt;/p&gt;

&lt;p&gt;The very first thing that you should do is, enable &lt;code&gt;failOnVersionConflict&lt;/code&gt; flag in gradle on version conflicts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;
configurations.all {
  resolutionStrategy.failOnVersionConflict()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should give you more idea about where in your code are version conflicts occuring which were getting implicitly resolved by gradle.&lt;/p&gt;

&lt;p&gt;Secondly, you can force gradle to resolve to the lower version&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;configurations.all {
  resolutionStrategy.force &#39;com.company4.sdk:libD:4.0.2&#39;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This changes the default behaviour of gradle.&lt;/p&gt;

&lt;p&gt;But wait! Resoltion strategy is still causing parts of the same dependency to conflict. HELP!&lt;/p&gt;

&lt;p&gt;Well only in that condition you should try and completely replace the whole module.&lt;/p&gt;

&lt;p&gt;Ho do you do it ? by including the below into your &lt;code&gt;build.gradle&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;// add dependency substitution rules
configurations.all {
  resolutionStrategy.dependencySubstitution {
    // Substitute one module dependency for another
    substitute module(&#39;com.company4.sdk:libD:4.0.4&#39;) with module(&#39;com.company4.sdk:libD:4.0.2&#39;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE : dependencySubstitution is an incubating functionality and may change in a future version of Gradle
As of writting this post the latest Gradle Version is 2.13 in which this is available.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thats pretty neat , isn&amp;rsquo;t it.&lt;/p&gt;

&lt;p&gt;I am pretty sure this would enable you to find the conflicts and solve it too.&lt;/p&gt;

&lt;p&gt;This also goes with the disclaimer that trying to resolve dependency conflicts this way is not the preferred way. You should always try to be using the latest version of the dependencies as well as maintain your library to use the same. This post basically defines the process to enable you to try and figure out why your build is failing and how to bypass it for the time being.&lt;/p&gt;

&lt;p&gt;Thats all for today folks.
Keep crushing code until next post :)&lt;/p&gt;

&lt;p&gt;Reference : &lt;a href=&#34;https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:failOnVersionConflict()&#34;&gt;Gradle Docs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>